Datastructure is a way of organizing data so that it can be used effectively

They are useful in creating fast and powerful algorithms and helps to manage and organize data

Abstract Data type Vs Data Structures

ADT - an abstraction of a data Structure which provides only the interface to which a data structure must adhere to.
The interface does not give any specific details about how something should be implemented or in what programming language

Abstract (ADT)
1. List - Dynamic Array, Linked List
2. Queue - Linked List based Queue, Array based Queue, Stack based Queue
3. Map - Tree Map, Hash Map/ Hash Table
Example: - Vehicle - Golf Cart, Bicycle, Smart Car

Computational Complexity Analysis
1. How much time does this algorithm takes to finish?
2. How much space does this algorithm needs for its Computation?

Big-O notation helps to quantify performance as the input size becomes arbitrarily large

n - Size of the input
Complexities Ordered from smallest to largest
Cnst Time : O(1)
Logarithmic Time: O(log(n))
Linear Time: O(n)
Linearithmic Time: O(n log(n))
Quadric Time:O(n2)
Cubic Time:O(n3)
Exponential Time:O(bn)
Factorial Time:O(n!)

Big-O properties
O(n+c) = O(n) example: - n+1,n+2,n+3,................ = n
O(cn) = O(n) when c>0, 1*n, 2*n, 3*n ========== n


Big-O Examples
a = 1
b = 2
c = a + 5 * b

The following run in constant time: O(1)
i=0
while i<10 do
    i+=1

Here the while statement will run only for 10 times which is defined constantly 
and does not depend on the value as in n, so the time Complexity is O(1)

Linear time:O(n)
i=0
while i<n do
    i+=1

f(n) = n
O(f(n)) = O(n)


i=0
while i<n do
    i+=3 //Here we are finishing the loop 3 times faster, so it is n/3

f(n) = n/3
O(f(n)) = O(n)


for(let i=0; i<n; i++) {
    for(let j=0; j<n; j++) {
        // the time complexity will be f(n) = n*n = O(n2)
    }
}

for(let i=0; i<n; i++) {
    for(j=i ; j<n; j++) {
        // Here j directly depends on i
        if i = 0, then we do n work
        i=1, n-1
        i=2, n-2
        i=3, n-3
        n+(n-1)+(n-2)+(n-3)+............+3+2+1
    }
}


n*(n+1)/2 = n2



Binary Search Algo of Logarithmic Complexity

low = 0
high = n-1

while low <= high do
    mid = (low+high)/2

    if(arr[mid] === value) : return mid
    else if(arr[mid] < value): low = mid + 1
    else if(arr[mid] > value) : high = mid - 1


Example 2
i = 0
while i < n do
    j = 0
    while j < 3*n do    
        j = j + 1
    j = 0
    while j < 2*n do   
        j = j + 1
    i = i + 1

// Here 3*n and 2*n are inside the n, so n * but 3*n and 2*n are seperated so 3*n + 2*n 
f(n) = n * (3n + 2n) = n * (5n) = 5n2

which equals as O(n2)

i = 0
while i < 3 * n do
    j = 10
    while j <= 50 do
        j = j + 1
    j = 0
    while j < n*n*n do
        j = j + 2
    i = i + 1

3n * (50 + n3/2) = O(n4)



Finding all subsets of a set = O(2n)
Finding all permutations of a string - O(n!)
Sorting using mergeSort - O(nlog(n))
Iterating over all the cells in a matrix of size n by m - O(nm)


Static and Dynamic Array

A static array is a fixed length container containing n elements indexable from the range[0,n-1]
Indexable - Each slot/index in the array can be referenced by a number

when and where is a static array can be used
1. Storing and accessing sequential data
2. Temporarily Storing objects
3. Used by IO routines as buffers
4. used in dynamic programming to cache answers to subproblems
5. Lookup tabels and inverse lookup tabels
6. can be used to return multiple values from a 


Complexity
Operations Static Array Dynamic Array
Access     O(1)         O(1)
Search     O(n)         O(n)
Insertion  N/A          O(n)
Appending  N/A          O(1)
Deletion   N/A          O(n)


Static Array
Array arr = [-1 12 -5 17 6 18 25 9 100]
              0  1  2  3 4  5  6 7  8

 Here, arr[0] = -1
       arr[1] = 12
       arr[9] = Array index out of bounds error

Dynamic Array
A = [34,4]
A.add(-7) = [34,4,-7]
A.add(34) = [34,4,-7,34]
A.remove(4) = [34,-7,34]

How can we implement a dynamic array?
one way is to use a static array
1. Create a static array with an initial capacity
2. Add elements to the underlying static array, keeping track of the number of elements
3. If adding another element will exceed the capacity, then Create a new static array with twice the capacity and copy the original elements into it
 